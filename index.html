<script type="module">
import { THREE, scene, camera, renderer } from "https://code4fukui.github.io/egxr.js/egxr.js";

const colors = [0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030];
let color = 0;

const bsize = 0.5;
const ngrid = 20;
const wgrid = bsize * ngrid / 2;

// Grid
const geometry = new THREE.BufferGeometry();
const vertices = new Float32Array([
  -wgrid, 0, 0,
  wgrid, 0, 0,
]);
const position = new THREE.BufferAttribute(vertices, 3);
geometry.setAttribute("position", position);

const linesMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
for (let i = 0; i <= ngrid; i++) {
  {
    const line = new THREE.Line(geometry, linesMaterial);
    line.position.z = i * bsize - wgrid;
    scene.add(line);
  }
  {
    const line = new THREE.Line(geometry, linesMaterial);
    line.position.x = i * bsize - wgrid;
    line.rotation.y = 90 * Math.PI / 180;
    scene.add(line);
  }
}

const plane = new THREE.Mesh(new THREE.PlaneGeometry(bsize * ngrid, bsize * ngrid));
plane.rotation.x = -90 * Math.PI / 180;
plane.position.y = -.01;
scene.add(plane);

const cube = new THREE.BoxGeometry(bsize, bsize, bsize);
const brush = new THREE.Mesh(cube, new THREE.MeshBasicMaterial({ color: colors[color], opacity: 0.4, transparent: true }));
brush.position.y = 2000;
scene.add(brush);

const render = () => {
  //renderer.render(scene, camera); // use setAnimationLoop instead
};

// interact
const objs = [plane, brush];

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2(0, -100);

const normalMatrix = new THREE.Matrix3();

let objectHovered = null;
let isShiftDown = false;

const interact = () => {
  if (objectHovered) {
    objectHovered.material.opacity = 1;
    objectHovered.material.transparent = false;
    objectHovered.material.needsUpdate = true;
    objectHovered = null;
  }

  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(objs);
  
  brush.position.y = 2000;
  if (intersects.length > 0) {
    const intersect = intersects[0].object != brush ? intersects[0] : intersects[1];
    if (intersect) {
      if (isShiftDown) {
        if (intersect.object != plane) {
          objectHovered = intersect.object;
          objectHovered.material.opacity = 0.5;
          objectHovered.material.transparent = true;
          objectHovered.material.needsUpdate = true;
          return;
        }
      } else {
        normalMatrix.getNormalMatrix(intersect.object.matrixWorld);
        const p = intersect.face.normal.clone().applyMatrix3(normalMatrix).normalize();
        const position = intersect.point.clone().add(p.multiplyScalar(bsize / 2));

        brush.position.x = Math.floor(position.x / bsize) * bsize + bsize / 2;
        brush.position.y = Math.floor(position.y / bsize) * bsize + bsize / 2;
        brush.position.z = Math.floor(position.z / bsize) * bsize + bsize / 2;
        return;
      }
    }
  }
};

// key
document.body.onkeydown = (event) => {
  const key = event.key;
  if (key == "Shift") {
    isShiftDown = true;
    interact();
    render();
  }
  const nkey = parseInt(key);
  if (nkey >= 0 && nkey <= 9) {
    color = nkey;
    brush.material.color = new THREE.Color(colors[color]);
    brush.material.needsUpdate = true;
    render();
  }
};

document.body.onkeyup = (event) => {
  const key = event.key;
  if (key == "Shift") {
    isShiftDown = false;
    interact();
    render();
  }
};

// mouse
let isMouseDown = false;
let onMouseDownTheta = 0;
let onMouseDownPhi = 0;
const onMouseDownPosition = new THREE.Vector2();
let theta = 45;
let phi = 60;
let radius = 10;

document.body.onmousedown = (event) => {
  event.preventDefault();

  isMouseDown = true;

  onMouseDownTheta = theta;
  onMouseDownPhi = phi;
  onMouseDownPosition.x = event.clientX;
  onMouseDownPosition.y = event.clientY;
};

const updateCamera = () => {
  camera.position.x = radius * Math.sin(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
  camera.position.y = radius * Math.sin(phi * Math.PI / 360);
  camera.position.z = radius * Math.cos(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
  camera.lookAt(new THREE.Vector3(0, 1, 0));
  camera.updateMatrix();
};

document.body.onmousemove = (event) => {
  event.preventDefault();

  if (isMouseDown) {
    theta = -((event.clientX - onMouseDownPosition.x) * 0.5) + onMouseDownTheta;
    phi = ((event.clientY - onMouseDownPosition.y) * 0.5) + onMouseDownPhi;
    phi = Math.min(180, Math.max(0, phi));

    updateCamera();
  }

  pointer.x = event.clientX / window.innerWidth * 2 - 1;
  pointer.y = -event.clientY / window.innerHeight * 2 + 1;
  interact();
  render();
};

document.body.onmouseup = (event) => {
  event.preventDefault();

  isMouseDown = false;

  onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
  onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

  if (onMouseDownPosition.length() > 5) {
    return;
  }

  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(objs);
  
  if (intersects.length > 0) {
    const intersect = intersects[0].object != brush ? intersects[0] : intersects[1];
    if (intersect) {
      if (isShiftDown) {
        if (intersect.object != plane) {
          scene.remove(intersect.object);
          const n = objs.indexOf(intersect.object);
          objs.splice(n, 1);
          return;
        }
      } else {
        normalMatrix.getNormalMatrix(intersect.object.matrixWorld);
        const p = intersect.face.normal.clone().applyMatrix3(normalMatrix).normalize();
        const position = intersect.point.clone().add(p.multiplyScalar(bsize / 4));

        const mat = new THREE.MeshBasicMaterial({ color: colors[color] });
        const voxel = new THREE.Mesh(cube, mat);
        voxel.position.x = Math.floor(position.x / bsize) * bsize + bsize / 2;
        voxel.position.y = Math.floor(position.y / bsize) * bsize + bsize / 2;
        voxel.position.z = Math.floor(position.z / bsize) * bsize + bsize / 2;
        scene.add(voxel);
        objs.push(voxel);
      }
    }
  }
  interact();
  render();
};
document.body.onmousewheel = (event) => {
  radius -= event.wheelDeltaY / 1000;
  updateCamera();

  interact();
  render();
};

updateCamera();
interact();
render();

renderer.setAnimationLoop(() => {
  renderer.render(scene, camera);
});
</script>
